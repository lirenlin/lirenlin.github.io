<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yet another site</title><link href="/" rel="alternate"></link><link href="/feeds/c.atom.xml" rel="self"></link><id>/</id><updated>2019-08-18T16:45:44+02:00</updated><entry><title>c++ enum class -- scoped and strongly typed enums</title><link href="/c-enum-class-scoped-and-strongly-typed-enums.html" rel="alternate"></link><updated>2019-08-18T16:45:44+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-08-18:c-enum-class-scoped-and-strongly-typed-enums.html</id><summary type="html">&lt;h2&gt;enum class&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;enumerator names are local to the enum&lt;/li&gt;
&lt;li&gt;their values do not implicitly convert to other types&lt;/li&gt;
&lt;li&gt;the underlying type of an enum can be specified.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;plain enum&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;enumerator names are in the same scope as the enum, causing name clashes.&lt;/li&gt;
&lt;li&gt;their values implicitly convert to intergers and other types&lt;/li&gt;
&lt;li&gt;the underlying type of an enum cannot be specified.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;enum and string mapping&lt;/h2&gt;
&lt;p&gt;Most of the time, we want a mapping between enum and string. So that we could
print some useful message. The most straight-forward way is to have a function
with switch statement inside. For each enumerators, return different
descriptive string. A mapping data structure could also be used for this
purpose.&lt;/p&gt;
&lt;p&gt;To save some typing work, one could use macros/pre-processor to help with
code-generation.&lt;/p&gt;
&lt;p&gt;Depending on how the string need to be, there are two cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;enum names themselves as strings
  There are various third-party code to do this. To list a few:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/aantron/better-enums"&gt;better enum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;better enum is using macro to help with code generation. A struct is used
to wrap all the functions. Conversion operator is defined so that, the
struct could be used as a normal enumerator in swith/comparison statements&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Neargye/magic_enum"&gt;magic_enum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;magic_enum is taking advantage of &lt;strong&gt;__PRETTY_FUNCTION__&lt;/strong&gt; compiler magic
constant to generate string from enumerators.&lt;/p&gt;
&lt;p&gt;This reuqires certain compiler support. gcc &amp;gt;= 9, clang/llvm &amp;gt;= 5.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
&lt;span class="nt"&gt;enum&lt;/span&gt; &lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;Color&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;RED,&lt;/span&gt; &lt;span class="err"&gt;GREEN,&lt;/span&gt; &lt;span class="err"&gt;BLUE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;returned&lt;/span&gt; &lt;span class="nt"&gt;by&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;function&lt;/span&gt; &lt;span class="nt"&gt;contains&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;enumerator&lt;/span&gt; &lt;span class="nt"&gt;v&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;representation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;E&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;enum&lt;/span&gt; &lt;span class="nt"&gt;type&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;v&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;enumerator&lt;/span&gt; &lt;span class="nt"&gt;of&lt;/span&gt; &lt;span class="nt"&gt;E&lt;/span&gt; &lt;span class="nt"&gt;enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;E&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;E&lt;/span&gt; &lt;span class="nt"&gt;v&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;getEnumName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;__PRETTY_FUNCTION__&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nt"&gt;getEnumName&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Color&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;GREEN&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;endl&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;The&lt;/span&gt; &lt;span class="nt"&gt;output&lt;/span&gt; &lt;span class="nt"&gt;will&lt;/span&gt; &lt;span class="nt"&gt;look&lt;/span&gt; &lt;span class="nt"&gt;like&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;getNameImpl&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt; =&lt;/span&gt;&lt;span class="nx"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt; =&lt;/span&gt; &lt;span class="nx"&gt;Color&lt;/span&gt;&lt;span class="nl"&gt;::BLUE&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
&lt;span class="err"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Other user supplied string mapping&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.stroustrup.com/C++11FAQ.html#enum"&gt;Bjarne Stroustrup's C++11 FAQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/18335861/why-is-enum-class-preferred-over-plain-enum"&gt;stackoverflow: Why is enum class preferred over plain enum?&lt;/a&gt;&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>Pointer to Implementation idiom</title><link href="/pointer-to-implementation-idiom.html" rel="alternate"></link><updated>2019-08-11T20:18:33+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-08-11:pointer-to-implementation-idiom.html</id><summary type="html">&lt;h2&gt;Keywords&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Reduce compilation dependency&lt;/li&gt;
&lt;li&gt;pointer to implementation, smart pointer&lt;/li&gt;
&lt;li&gt;forward declaration&lt;/li&gt;
&lt;li&gt;incomplete type&lt;/li&gt;
&lt;li&gt;constness forwarding&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reference:&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.fluentcpp.com/2017/09/22/make-pimpl-using-unique_ptr/"&gt;fluent c++&lt;/a&gt;
&lt;a href="https://www.bfilipek.com/2018/01/pimpl.html"&gt;The Pimpl Pattern - what you should know &lt;/a&gt;
&lt;a href="https://herbsutter.com/gotw/_100/"&gt;GotW&lt;/a&gt;&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>Template dependent name</title><link href="/template-dependent-name.html" rel="alternate"></link><updated>2019-08-06T22:51:38+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-08-06:template-dependent-name.html</id><summary type="html">&lt;p&gt;https://en.cppreference.com/w/cpp/language/dependent_name&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>c++ type sepcifier, modifier, qualifier</title><link href="/c-type-sepcifier-modifier-qualifier.html" rel="alternate"></link><updated>2019-08-03T21:26:03+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-08-03:c-type-sepcifier-modifier-qualifier.html</id><summary type="html">&lt;h1&gt;type modifier&lt;/h1&gt;
&lt;p&gt;A modifier is used to alter the meaning of the base type so that it more
precisely fits the needs of various situations.
  * size
  * sign&lt;/p&gt;
&lt;h1&gt;access modifier&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;private&lt;/li&gt;
&lt;li&gt;public&lt;/li&gt;
&lt;li&gt;protected&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;qualifier&lt;/h1&gt;
&lt;p&gt;The type qualifiers provide additional information about the variables they precede.
  * const
  * volatile
  * restrict&lt;/p&gt;
&lt;h1&gt;type specifier&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;friend&lt;/li&gt;
&lt;li&gt;inline&lt;/li&gt;
&lt;li&gt;constexpr&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;storage specifier&lt;/h1&gt;
&lt;h1&gt;format specifier&lt;/h1&gt;
&lt;p&gt;https://stackoverflow.com/questions/35218641/what-are-declarator-specifiers-in-c-language&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>c++ term</title><link href="/c-term.html" rel="alternate"></link><updated>2019-07-28T12:43:31+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-07-28:c-term.html</id><summary type="html">&lt;p&gt;closure
free varialbe
first order function&lt;/p&gt;
&lt;p&gt;callable object
  * function object, functor
  A function object (or functor) is simply any object of a class that provides at least one definition for operator() What this means is that if you then declare an object f of the class in which this operator() is defined you can subsequently use that object f just like you would use an "ordinary" function.
  * lambda expression
  * bind expression
  * free functions
  * member functions&lt;/p&gt;
&lt;p&gt;STL function objects
type erasure&lt;/p&gt;
&lt;h1&gt;why lambda expression could be inlined?&lt;/h1&gt;
&lt;p&gt;https://stackoverflow.com/questions/13722426/why-can-lambdas-be-better-optimized-by-the-compiler-than-plain-functions&lt;/p&gt;
&lt;p&gt;lambda expression are function object.
its type is passed to the a function template, which will results in a specific
version for this template type argument.&lt;/p&gt;
&lt;p&gt;In this case, the compiler knows the type and implementation of function call operator. It has better chances to do some optimizations.&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>std::bind vs lambda</title><link href="/stdbind-vs-lambda.html" rel="alternate"></link><updated>2019-07-27T21:00:09+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-07-27:stdbind-vs-lambda.html</id><summary type="html">&lt;h1&gt;lambda vs std::bind&lt;/h1&gt;
&lt;p&gt;基本上是两个不同的用途，但是lambda可以实现std::bind的功能.
如果目的知识想去创造一个scope临时的函数，例如提供给STL的函数。lambda非诚使用这种使用场景。
1. 不需要单独的写一个函数，与使用逻辑分开。非常紧凑，没有context switch
2. lambda 可以inline，compiler可以做更多的优化&lt;/p&gt;
&lt;p&gt;但是如果lambda只是capture variable，然后调用另一个外部函数的话，bind更加的简单直接。
"Simpler and clearer" is a matter of opinion. For simple binding cases, bind can take a lot less typing. bind also is focused solely on function binding, so if you see std::bind, you know what you're looking at. Whereas if you use a lambda, you have to look at the lambda implementation to be certain of what it does.&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/15598607/when-should-i-use-stdbind&lt;/p&gt;
&lt;p&gt;但是注意，std::bind参数的传递只能通过copy, move。不能通过reference。这需要通过std::ref/std::cref&lt;/p&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;functional&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;_a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
  &lt;span class="c1"&gt;// deleted copy constructor, std::bind will fail because of this. It cannot&lt;/span&gt;
  &lt;span class="c1"&gt;// make a copy for the binding arguments. Instead std::ref could be used to&lt;/span&gt;
  &lt;span class="c1"&gt;// pass remove the copy operation&lt;/span&gt;
  &lt;span class="nx"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;getResult&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;_a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
  &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;inc() {_a&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;

&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// declaration doesn&amp;#39;t affected by class access specifier&lt;/span&gt;
  &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; data object: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;_a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;foo_cref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getResult&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;foo_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getResult&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;Data&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This will fail as std::bind will copy or move the arguments. arguments are&lt;/span&gt;
  &lt;span class="c1"&gt;// never passed by reference unless wrapped in std::ref or std::cref&lt;/span&gt;
  &lt;span class="c1"&gt;// https://en.cppreference.com/w/cpp/utility/functional/bind&lt;/span&gt;
  &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="nx"&gt;fail_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;bind&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;foo_cref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="nx"&gt;cref_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;bind&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;foo_cref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;cref_func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// value could be updated inside the function object&lt;/span&gt;
  &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="nx"&gt;func_ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;bind&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;foo_ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;func_ref&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Rerefence:&lt;/h1&gt;
&lt;p&gt;http://www.gockelhut.com/cpp-pirate/lambda-vs-bind.html&lt;/p&gt;
&lt;p&gt;https://shawnliu.me/post/passing-reference-with-std-ref-in-c++/&lt;/p&gt;
&lt;p&gt;https://github.com/peter-can-write/cpp-notes/blob/master/prefer-lambdas-over-std::bind.md&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>c++ method chaining</title><link href="/c-method-chaining.html" rel="alternate"></link><updated>2019-07-01T22:21:49+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-07-01:c-method-chaining.html</id><summary type="html">&lt;p&gt;Some class methods return object reference to itself. This is for method
chaining.&lt;/p&gt;
&lt;p&gt;Reference:&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>c++ algorithm</title><link href="/c-algorithm.html" rel="alternate"></link><updated>2019-06-22T18:47:43+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-06-22:c-algorithm.html</id><summary type="html">&lt;p&gt;std::all_of
std::any_of
std::none_of&lt;/p&gt;
&lt;p&gt;std::partial_sum&lt;/p&gt;
&lt;p&gt;std::lower_bound
std::upper_bound
binary search&lt;/p&gt;
&lt;p&gt;std::unique
std::sort&lt;/p&gt;
&lt;p&gt;std::remove
std::remove_if
one iteration, vector remove/erase idiom&lt;/p&gt;
&lt;p&gt;std::copy
std::copy_if
std::copy_n
std::copy_backward
&lt;code&gt;`
std::copy(to_vector.begin(), to_vector.end(),
          std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, " "));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;std::for_each, UnaryFunction
std::for_each_n&lt;/p&gt;
&lt;p&gt;std::transform, UnaryOperation or BinaryOperation&lt;/p&gt;
&lt;p&gt;std::count
std::count_if&lt;/p&gt;
&lt;p&gt;std::equal&lt;/p&gt;
&lt;p&gt;std::find_end
std::search
std::search_n
std::find_first_of
std::adjacent_find&lt;/p&gt;
&lt;p&gt;range based for loop&lt;/p&gt;
&lt;p&gt;std::back_inserter
std::distance&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>c++ notes</title><link href="/c-notes.html" rel="alternate"></link><updated>2019-06-22T17:40:22+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-06-22:c-notes.html</id><summary type="html">&lt;p&gt;https://stackoverflow.com/questions/1600936/officially-what-is-typename-for&lt;/p&gt;</summary><category term="c++"></category></entry><entry><title>c++ std::vector</title><link href="/c-stdvector.html" rel="alternate"></link><updated>2019-06-20T20:50:00+02:00</updated><author><name>Nekoo</name></author><id>tag:,2019-06-20:c-stdvector.html</id><summary type="html">&lt;h1&gt;c++ range base for loop over vector&lt;/h1&gt;
&lt;p&gt;If you don't want to change the items as well as want to avoid making copies, then auto const &amp;amp; is the correct choice:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (auto const &amp;amp;x : vec)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Whoever suggests you to use auto &amp;amp; is wrong. Ignore them.&lt;br /&gt;
Here is recap:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choose &lt;code&gt;auto x&lt;/code&gt; when you want to work with copies.&lt;/li&gt;
&lt;li&gt;Choose &lt;code&gt;auto &amp;amp;x&lt;/code&gt; when you want to work with original items and may modify them.&lt;/li&gt;
&lt;li&gt;Choose &lt;code&gt;auto const &amp;amp;x&lt;/code&gt; when you want to work with original items and will not modify them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Does “X&amp;amp; const x” make any sense?&lt;/h1&gt;
&lt;p&gt;referece is alwas const. You cannot modify it to reference another item.
reference to a const item is normally what people expect.
This is &lt;code&gt;const T&amp;amp; x&lt;/code&gt;, instead of &lt;code&gt;T&amp;amp; const x&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;vector remove/erase idiom&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;vec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;myNumbers&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;use&lt;/span&gt; &lt;span class="nt"&gt;shorter&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;
&lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;erase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;end&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="nt"&gt;number_in&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;end&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;Remove will not change the size of vector, it will shift other item forward to
overwrite the given item. An iterator to the next item will be returned.&lt;/li&gt;
&lt;li&gt;erase is needed to erase those items starting from the iterator. The size of
the vector will also be updated accordingly.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;vector remove duplicate idiom&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;end&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;erase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;unique&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;end&lt;/span&gt;&lt;span class="o"&gt;()),&lt;/span&gt; &lt;span class="nt"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;end&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;sort will make the items with same value consecutive in memory.&lt;/li&gt;
&lt;li&gt;unique will shift items forward to eliminate all but the first element from
every consecutive group of equivalent elements from the range. It returns a
past-the-end iterator for the new logical end of the range.&lt;/li&gt;
&lt;li&gt;erase will erase items in the range.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Reference:&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/15176104/c11-range-based-loop-get-item-by-value-or-reference-to-const"&gt;c++ range based loop&lt;/a&gt;
&lt;a href="https://isocpp.org/wiki/faq/const-correctness#const-ref-nonsense"&gt;ISOCPP FAQ. Does “X&amp;amp; const x” make any sense?&lt;/a&gt;
&lt;a href="https://stackoverflow.com/questions/1041620/whats-the-most-efficient-way-to-erase-duplicates-and-sort-a-vector"&gt;stackoverflow: What's the most efficient way to erase duplicates and sort a vector?&lt;/a&gt;&lt;/p&gt;</summary><category term="C++"></category></entry></feed>