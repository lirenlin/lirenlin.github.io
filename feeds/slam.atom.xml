<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yet another site</title><link href="/" rel="alternate"></link><link href="/feeds/slam.atom.xml" rel="self"></link><id>/</id><updated>2019-01-15T08:36:12+01:00</updated><entry><title>简单BA代码分析</title><link href="/jian-dan-badai-ma-fen-xi.html" rel="alternate"></link><updated>2019-01-15T08:36:12+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-01-15:jian-dan-badai-ma-fen-xi.html</id><summary type="html">&lt;p&gt;简单代码分析，帮助自己从概念到代码的理解。代码使用Eigen, ceres solver第三方软件库。&lt;/p&gt;
&lt;h1&gt;问题假设&lt;/h1&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P^{c}_{ij}\)&lt;/span&gt;: 路标(point)j在i相机位姿下，在相机坐标下的观测坐标&lt;span class="math"&gt;\([Px^{c} Py^{c}]^T\)&lt;/span&gt;(观测数据)&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(T_{i} = [rotation matrix, translation]\in \mathbb {R}^{6}\)&lt;/span&gt; 或者&lt;span class="math"&gt;\(T = [Quaternion, translation] \in \mathbb {R}^{7}\)&lt;/span&gt; 相机位姿(pose)初始估计 (前端计算数据)&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P^{w}_{j} = [Px^{w} Py^{w} Pz^{w}]\)&lt;/span&gt;路标(point)在世界坐标系下的初始估计值(前端计算数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经过调整后相机的位姿(pose)&lt;/li&gt;
&lt;li&gt;与调整后的路标在世界坐标系下的坐标。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$ \overline {P^{c}_{ij}} = h(T_{i}, P^{w}_{ij})$$&lt;/div&gt;
&lt;p&gt;
给定相机位姿，路标世界坐标，计算投影坐标&lt;span class="math"&gt;\(h : SE(3) × \mathbb {R}^{3} \to \mathbb {R}^{2}\)&lt;/span&gt;
因为投影为平面，所以只有二维，世界坐标维三维。&lt;/p&gt;
&lt;p&gt;cost function, reprojection error:
&lt;/p&gt;
&lt;div class="math"&gt;$$ e = \sum_{i} {\sum_{j} {\Vert(h(T_{i}, P^{w}_{ij}) - P^{c}_{ij})\Vert^2}}$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(h\)&lt;/span&gt;这里可以分为两步
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
P^{w'} &amp;amp;= f(T, P^{w}) = TP^{w} = RP^{w} + t: \mathbb {R}^3 \to \mathbb {R}^3 \\
\overline {P^{c}} &amp;amp;= g(P^{w'}) = [\frac {Px^{w'}}{Pz^{w'}} \frac{Py^{w'}}{Pz^{w'}}]^T: \mathbb {R}^3 \to \mathbb {R}^2 \\
\overline {P^{c}} &amp;amp;= g(f(T, P^{w}))
\end{align*}&lt;/div&gt;
&lt;p&gt;非线性最小二乘优化，迭代方法，需要求得对于优化标量偏导Jacobian矩阵,
  以及迭代更新计算。这里，优化的变量为位姿&lt;span class="math"&gt;\(T \in \mathbb {R}^6\)&lt;/span&gt;与&lt;span class="math"&gt;\(P^{w} \in
  \mathbb {R}^3\)&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;cost function Jabian矩阵推导&lt;/h1&gt;
&lt;p&gt;根据求导chain rule:
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
1)\; \pdiff{h}{P^{w}} &amp;amp;= \pdiff{g(P^{w'})}{f}\pdiff{f}{P^{w}}\\
2)\; \pdiff{h}{T} &amp;amp;= \pdiff{g(P^{w'})}{f}\pdiff{f}{T}\\
\end{align*}&lt;/div&gt;
&lt;div class="math"&gt;\begin{gather*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
\pdiff{g(P^{w'})}{f} &amp;amp;= 
\left[
  \begin{array}{ccc}
  \frac {1}{Pz^{w'}} &amp;amp; 0 &amp;amp; \frac {Px^{w'}}{(Pz^{w'})^2} \\
  0 &amp;amp; \frac {1}{Pz^{w'}} &amp;amp; \frac {Py^{w'}}{(Pz^{w'})^2} \\
  \end{array}
\right] = \frac {1}{Pz^{w'}}
\left[
  \begin{array}{ccc}
  1 &amp;amp; 0 &amp;amp; \frac {Px^{w'}}{Pz^{w'}} \\
  0 &amp;amp; 1 &amp;amp; \frac {Py^{w'}}{Pz^{w'}} \\
  \end{array}
\right]
\end{gather*}&lt;/div&gt;
&lt;p&gt;这里2)的导数在SE(3)空间无法计算，因为没有定义的加法，因此使用lie group与lie
algebra计算。
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
\pdiff{f}{T} \to \pdiff{TP}{\delta\xi}
&amp;amp;= \lim_{\delta\xi \to 0}{\frac {exp(\delta\xi^{\wedge})exp(\xi^{\wedge})P -exp(\xi^{\wedge})P}{\delta\xi}} \\
&amp;amp;\approx \lim_{\delta\xi \to 0}{\frac {(I + \delta\xi^{\wedge})exp(\xi^{\wedge})P -exp(\xi^{\wedge})P}{\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac {\delta\xi^{\wedge}exp(\xi^{\wedge})P}{\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left [\begin{array}{cc} \delta\varphi^{\wedge} &amp;amp; \delta\rho \\ 0^T &amp;amp; 0 \\ \end{array} \right] \left[ \begin{array}{c} RP + t \\ 1 \end{array} \right]}
      {\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left[ \begin{array}{c} \delta\varphi^{\wedge}(RP + t) + \delta\rho \\ 0 \end{array} \right]}
      {\delta\xi}}
\end{align*}&lt;/div&gt;
&lt;p&gt;T对应的李代数为&lt;span class="math"&gt;\(\delta\xi = [\delta\varphi \; \delta\rho]^T\)&lt;/span&gt;, 对他们按顺序求导得到
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
\pdiff{f}{T} \to \pdiff{TP}{\delta\xi}
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left[ \begin{array}{c} \delta\varphi^{\wedge}P^{w'} + \delta\rho \\ 0 \end{array} \right]}
      {\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left[ \begin{array}{c} -{P^{w'}}^{\wedge}\delta\varphi + \delta\rho \\ 0 \end{array} \right]}
      {\delta\xi}} \\
&amp;amp;= \left[ \begin{array}{cc} -{P^{w'}}^{\wedge} &amp;amp; I \\ 0^T &amp;amp; 0^T \end{array} \right]
\end{align*}&lt;/div&gt;
&lt;p&gt;推导过程与这里想吻合，具体计算可以参考这里代码.&lt;/p&gt;
&lt;p&gt;&lt;a href="/pdfs/Visual_SLAM_Tutorial_Bundle_Adjustment.pdf"&gt;Visual SLAM Tutorial: Bundle Adjustment&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://github.com/lirenlin/ba_demo_ceres"&gt;github source code fork&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;优化参量更新&lt;/h1&gt;
&lt;p&gt;注意这里对李代数求导，对于原参数的更新，必须返回到SE(3)。
&lt;/p&gt;
&lt;div class="math"&gt;$$X = X + \Delta X$$&lt;/div&gt;
&lt;p&gt;
这里&lt;span class="math"&gt;\(\Delta X\)&lt;/span&gt;是用Jacobian矩阵求得。因为位姿相关部分是用李代数求得，所以&lt;span class="math"&gt;\(\Delta X\)&lt;/span&gt;位姿更新部分也是李代数，
在更新T参数时，需要变换到SE(3)下。对于路标位置，可以直接更新。
这个使用ceres solver里面的LocalParameterization实现，重载plus成员函数。&lt;/p&gt;
&lt;p&gt;从李代数到Transform matrix的转换在《视觉slam十四讲》李代数章节讲的很清楚。&lt;/p&gt;
&lt;p&gt;so(3)李代数实际上由旋转向量组成，所以转换遵循Angle-Aix, Rotation matrix, Quaternion变换关系。&lt;/p&gt;
&lt;h1&gt;代码备注&lt;/h1&gt;
&lt;p&gt;Eigen库里面有大量的运算符重载，例如四元数表示的旋转可以直接与三维坐标想成得到旋转后的向量。
在数学上是不行的。&lt;/p&gt;
&lt;h1&gt;继续学习&lt;/h1&gt;
&lt;p&gt;李群，李代数的数学意义，manifold tangent space目前还是不清楚。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《视觉slam十四讲》  &lt;/li&gt;
&lt;li&gt;&lt;a href="/pdfs/Visual_SLAM_Tutorial_Bundle_Adjustment.pdf"&gt;Visual SLAM Tutorial: Bundle Adjustment&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/lirenlin/ba_demo_ceres"&gt;github source code fork&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/sVjy9kr-8qc9W9VN78JoDQ"&gt;李代数讲解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="BundleAdjustment"></category></entry></feed>