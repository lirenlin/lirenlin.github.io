<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yet another site</title><link href="/" rel="alternate"></link><link href="/feeds/slam.atom.xml" rel="self"></link><id>/</id><updated>2019-02-19T19:01:19+01:00</updated><entry><title>Data Association</title><link href="/data-association.html" rel="alternate"></link><updated>2019-02-19T19:01:19+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-19:data-association.html</id><summary type="html">&lt;h2&gt;Mahalanobis distance&lt;/h2&gt;
&lt;h2&gt;Random sample consensus (RANSAC)&lt;/h2&gt;
&lt;p&gt;Random sample consensus (RANSAC) is an iterative method to estimate parameters
of a mathematical model from a set of observed data that contains outliers,
when outliers are to be accorded no influence on the values of the estimates.
Therefore, it also can be interpreted as an outlier detection method.[1] It is
a non-deterministic algorithm in the sense that it produces a reasonable result
only with a certain probability, with this probability increasing as more
iterations are allowed.&lt;/p&gt;
&lt;p&gt;直观上，可以一定程度上的排除outliers。有两个应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统参数的估计/拟合。给定一组带有噪声的数据与一个系统模型，通过数据来确定系统
模型的参数。因为数据中外点，会导致拟合的系统出现偏移。所以去除外点对于正确的系统
估计很重要。
同时，外点不同于噪点，噪点可以通过统计的方式消除，当然还需要数据量足够大才行。&lt;/li&gt;
&lt;li&gt;图像特征匹配中，消除误匹配点。
在图像特征匹配以后，会得到很多对特征匹配。但是其中有一些匹配是误匹配，如果不加挑选，
使用所有的匹配对进行运动的计算，可能会得到错误的运动数据(旋转，平移)。RANSAC可以用来
消除误匹配，然后使用剩下的匹配来估计运动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述过程类似，
1. 随机选取n个数据点
2. 根据一个给定模型，计算模型参数
3. 从原始数据集合中，根据上述求得模型，寻找其他的符合这个模型的数据点(在一定误差范围内)，
加入到一个集合里。称为内点集合
4. 如果总的内点个数大于M，则利用内点集合，重新估计模型参数，计算整体(使用所有数据点)误差。
跟上一次整体误差比较，如果误差更小，则更新误差，记录模型参数。
5. 跳转到步骤一，继续下一次迭代。直到迭代次数达到，或者整体误差小于一个预定值。&lt;/p&gt;
&lt;p&gt;从上面步骤中看出，这个迭代过程，有很多参数需要设置。这也是RANSAC的一个缺点。&lt;/p&gt;
&lt;h2&gt;Probabilistic data association filter&lt;/h2&gt;
&lt;h2&gt;ICP&lt;/h2&gt;
&lt;p&gt;通过迭代的方式，来解决data association与变换矩阵问题。&lt;/p&gt;
&lt;h3&gt;point subset&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use all points&lt;/li&gt;
&lt;li&gt;Uniform sub-sampling&lt;/li&gt;
&lt;li&gt;Random sampling&lt;/li&gt;
&lt;li&gt;Feature based sampling&lt;/li&gt;
&lt;li&gt;Normal-space sampling&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;weighting the correspondences&lt;/h3&gt;
&lt;h3&gt;data association&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;closet point&lt;/li&gt;
&lt;li&gt;normal shooting&lt;/li&gt;
&lt;li&gt;closest compatible point&lt;/li&gt;
&lt;li&gt;projection-based&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;rejecting certain (outlier) point pairs&lt;/h3&gt;</summary><category term="SLAM"></category></entry><entry><title>Sensors</title><link href="/sensors.html" rel="alternate"></link><updated>2019-02-17T15:54:30+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-17:sensors.html</id><summary type="html">&lt;h1&gt;Sensor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Proprioceptive sensors&lt;ul&gt;
&lt;li&gt;Motor speed, heading of the robot&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exteroceptive sensors&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distances to objects, images&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Passive sensors&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Measure energy coming from the environment, very much influenced by
the environment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Active sensors&lt;ul&gt;
&lt;li&gt;emit their proper energy and measure the reaction. Better
performance, but some influence on environment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;some encoders, PC, P
Vision-based sensors, EC, P
Active ranging, EC, A&lt;/p&gt;
&lt;p&gt;compass: 罗盘, magnetic field on earth
gyroscope: 陀螺仪
provide an absolute measure for the heading of a mobile system&lt;/p&gt;
&lt;p&gt;inclinometer: 测斜仪
Accelerometer&lt;/p&gt;
&lt;h2&gt;IMU: Inertial Measurement Unit&lt;/h2&gt;
&lt;p&gt;An inertial measurement unit (IMU) is a device that uses measurement systems
such as gyroscopes and accelerometers to estimate the relative position (x, y, z),
orientation (roll, pitch, yaw), velocity, and acceleration of a moving
vehicle with respect to an inertial frame.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IMUs are extremely sensitive to measurement errors in gyroscopes and
accelerometers: drift in the gyroscope unavoidably undermines the estimation of
the vehicle orientation relative to gravity, which results in incorrect
cancellation of the gravity vector. Additionally observe that, because the
accelerometer data is integrated twice to obtain the position, any residual
gravity vector results in a quadratic error in position.&lt;/li&gt;
&lt;li&gt;After long period of operation, all IMUs drift.  To cancel it, some external
reference like GPS or cameras has to be used&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Beacons&lt;/h2&gt;
&lt;p&gt;Beacons are signaling guiding devices with a precisely known position&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beacons require changes in the environment. Initial setup and maintain -&amp;gt; costly.&lt;/li&gt;
&lt;li&gt;Limit flexibility and adaptability to changing environment.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Augmented Reality Tag&lt;/h2&gt;
&lt;h2&gt;Global Position System&lt;/h2&gt;
&lt;h3&gt;Differential Global Positioning System (dGPS)&lt;/h3&gt;
&lt;p&gt;DGPS requires that a GPS receiver, known as the base station, be set up on a
precisely known location.The base station receiver calculates its position
based on satellite signals and compares this location to the known location.
The difference is applied to the GPS data recorded by the roving GPS receiver&lt;/p&gt;
&lt;p&gt;position accuracies in sub-meter to cm range&lt;/p&gt;
&lt;h2&gt;Range sensors&lt;/h2&gt;
&lt;p&gt;Large range distance measurement. key element for localization and environment
modeling&lt;/p&gt;
&lt;p&gt;Ultrasonic sensors as well as laser range sensors make use of propagation speed
of sound or electromagnetic waves respectively.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quality of time of flight range sensors&lt;ul&gt;
&lt;li&gt;Inaccuraciesin the time of fight measurement(laser range sensors)&lt;/li&gt;
&lt;li&gt;Opening angle of transmitted beam (especially ultrasonic range sensors)&lt;/li&gt;
&lt;li&gt;Interaction with the target (surface, specular reflections)&lt;/li&gt;
&lt;li&gt;Variation of propagation speed (sound)&lt;ul&gt;
&lt;li&gt;sound&lt;/li&gt;
&lt;li&gt;electromagnetic signal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Speed of mobile robot and target (if not at stand still)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Laser Range finder are also known as Lidar (Light Detection And Ranging)&lt;/p&gt;
&lt;h3&gt;Sonar&lt;/h3&gt;
&lt;h3&gt;Laser range finder&lt;/h3&gt;
&lt;h1&gt;Sensor Model&lt;/h1&gt;
&lt;h1&gt;Sensor Fusion&lt;/h1&gt;
&lt;p&gt;https://www.ethz.ch/content/dam/ethz/special-interest/mavt/robotics-n-intelligent-systems/asl-dam/documents/lectures/autonomous_mobile_robots/spring-2015/04_-&lt;em&gt;Perception_I&lt;/em&gt;-_Sensors.pdf&lt;/p&gt;</summary><category term="SLAM"></category></entry><entry><title>位姿图优化空间平移问题</title><link href="/wei-zi-tu-you-hua-kong-jian-ping-yi-wen-ti.html" rel="alternate"></link><updated>2019-02-16T20:20:10+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-16:wei-zi-tu-you-hua-kong-jian-ping-yi-wen-ti.html</id><summary type="html">&lt;p&gt;A Tutorial on Graph-Based SLAM&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;
中有提到一个细节，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that the error of a constraint &lt;span class="math"&gt;\(e_{ij}\)&lt;/span&gt; depends only on the relative position
of the connected pose &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; and &lt;span class="math"&gt;\(x_j\)&lt;/span&gt;.  Accordingly, the error &lt;span class="math"&gt;\(F(x)\)&lt;/span&gt; of a
particular configuration of the pose sxis invariant under a rigid transformation
of all the poses. This results in Eq. 15 being under determined. To numerically
solve this system it is therefore common practiceto constrain one of the
increments &lt;span class="math"&gt;\(\Delta x_k\)&lt;/span&gt; to be zero. This can bedone by adding the identity matrix to
thekthdiagonal block &lt;span class="math"&gt;\(H[kk]\)&lt;/span&gt;.  Without loss of generality in Algorithm 1 we
fix the first node &lt;span class="math"&gt;\(x1\)&lt;/span&gt;. An alternative way to fix a particular node
of the pose-graph consists in suppressing the kth block row and the kth block column
of the linear system in Eq. 15.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class="math"&gt;\(e_{ij}\)&lt;/span&gt;约束的误差，只取决于&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;与&lt;span class="math"&gt;\(x_j\)&lt;/span&gt;的相对位置。如果所有的位姿点，统一进行一个刚体
变换，那么目标error function是不变的，系统欠定，有无数解。&lt;/p&gt;
&lt;p&gt;同样更广泛的问题在Visual SLAM Tutorial: Bundle Adjustment&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;中，有专门一章节来描述。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf"&gt;A Tutorial on Graph-Based SLAM&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="/pdfs/Visual_SLAM_Tutorial_Bundle_Adjustment.pdf"&gt;Visual SLAM Tutorial: Bundle Adjustment&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="SLAM"></category></entry><entry><title>BA vs Graph SLAM</title><link href="/ba-vs-graph-slam.html" rel="alternate"></link><updated>2019-02-15T13:05:07+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-15:ba-vs-graph-slam.html</id><summary type="html">&lt;p&gt;state vector
error function&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parameterization for the state vector&lt;ul&gt;
&lt;li&gt;minimum parameterization, 对于分量是分别计算的，在有冗余的时候，例如旋转矩阵R，他们之间的约束没有表示出来，会求得不合理的组合
但是对于 minimum parameterization，可能不存在欧式空间的加法。不连续可导。&lt;/li&gt;
&lt;li&gt;Extended parameterization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class="math"&gt;\([x, y, \theta]\)&lt;/span&gt; or &lt;span class="math"&gt;\(T \to \mathbb SE(3)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It is a well known thing that 3D rotations can be parameterized with a
rotation matrix R. A rotation matrix, however has 9 numbers to represent 3 angles. If we would use
the rotation matrices as parameters in our optimization mechanism we would find non-valid solutions,
since the orthogonality constraint is not enforced. Thus, it seems there is no alternative than carrying
on the optimization by using a minimal representation, for instance Euler angles. But we just said that
Euler angles suffer of singularities. Lucky us, the rotations are a manifold. That is, they admit a local
parameterization which is homeomorphic to the vector space Rn . To explain this sentence, think to a
generic rotation R(ρ, θ, ψ). We can easily define a mapping between rotation matrices and Euler angles,
and vice versa:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;if the state variable do not live in Euclidean space&lt;ul&gt;
&lt;li&gt;define a parameterization for the increment&lt;/li&gt;
&lt;li&gt;define &lt;span class="math"&gt;\(\boxplus\)&lt;/span&gt; operator.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;local parameterization of the increments &lt;span class="math"&gt;\(\Delta X\)&lt;/span&gt; if X is not in E&lt;/p&gt;
&lt;p&gt;iteration state vector update
&lt;span class="math"&gt;\(X = X \boxplus \Delta X\)&lt;/span&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="SLAM"></category></entry><entry><title>Graph SLAM总结</title><link href="/graph-slamzong-jie.html" rel="alternate"></link><updated>2019-02-14T16:21:45+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-14:graph-slamzong-jie.html</id><summary type="html">&lt;h2&gt;Vertex&lt;/h2&gt;
&lt;p&gt;图的顶点，代表待优化的变量，具体表示形式取决于参数化(parameterazation)。&lt;/p&gt;
&lt;p&gt;顶点可以是多种形式，例如SLAM问题中的机器人位姿(pose)，或者路标的坐标(三维空间&lt;span class="math"&gt;\([x,y,z]\)&lt;/span&gt;，或者二维空间坐标&lt;span class="math"&gt;\([x,y]\)&lt;/span&gt;)。同时，位姿也可以用不同的参数表达，可以是两个位姿间的变化矩阵&lt;span class="math"&gt;\(T\)&lt;/span&gt;，或者是3DoF下的位置与转角&lt;span class="math"&gt;\([x,y,\theta]\)&lt;/span&gt;。可以融合多种信息，统一求解，非常的灵活。&lt;/p&gt;
&lt;h2&gt;Edge&lt;/h2&gt;
&lt;p&gt;相应的，不同顶点之间，需要合适的边连接起来，表示它们之间的约束与变换。这个需要与顶点的性质统一。&lt;/p&gt;
&lt;p&gt;例如，位姿顶点之间，是通过运动方程的边连接。位姿顶点与路标顶点，是通过观测方程连接。在没有相关信息的时候，也可以通过其他信息推导。例如在没有运动方程信息的时候，可以通过scan to scan match来获取pose之间的估计。但是，总体来说，信息越多，通过融合后的预测结果越可信。&lt;/p&gt;
&lt;p&gt;上述距离中，边为二元边，边的起始和结束，连接两个不同的顶点。边也可以是一元边，例如线性拟合问题，拟合的参数为一个顶点，多个采样点构成一元边，起始于参数顶点，结束于参数顶点，具体例子可以参考，视觉SLAM十四讲中的例子。&lt;/p&gt;
&lt;p&gt;举例，对于二维SLAM问题，定义两种顶点:
机器人pose, &lt;span class="math"&gt;\([x, y, \theta]\)&lt;/span&gt;
路标坐标, &lt;span class="math"&gt;\([x, y]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;运动方程，
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x): \mathbbR^3 \to \mathbbR^3$$&lt;/div&gt;
&lt;p&gt;
观测方程，
&lt;/p&gt;
&lt;div class="math"&gt;$$h(x): \mathbbR^3 \to \mathbbR^2$$&lt;/div&gt;
&lt;p&gt;pose to pose constraint:
&lt;span class="math"&gt;\(T_i = \Delta T_{ij} T_{j}\)&lt;/span&gt;
某个pose处，激光测量，观测到一个空间点，顶点为一个2D pose: &lt;span class="math"&gt;\([x, y, \theta]^T\)&lt;/span&gt; 和一个point: &lt;span class="math"&gt;\([\lambda_x, \lambda_y]^T\)&lt;/span&gt;, 观测数据是Polar坐标， 距离r与角度b
&lt;/p&gt;
&lt;div class="math"&gt;$$[r,b] = []$$&lt;/div&gt;
&lt;h2&gt;误差最小化least square error&lt;/h2&gt;
&lt;p&gt;对于待优化的变量，不管是位姿还是坐标，都是矢量，以向量的形式存储。其误差也是向量形式。但是最小二乘问题的目标函数，要求是一个标量。最直观的方式是取模(norm, 2范数)，也就是”平方“。矩阵形式为&lt;span class="math"&gt;\(e^Te\)&lt;/span&gt;。同时为了表示对于个误差分量都的重视程度(精确度的信任度)不一样，还是用一个信息矩阵&lt;span class="math"&gt;\(\Omega\)&lt;/span&gt;来进行不同的加权，总体的目标函数写成：
&lt;/p&gt;
&lt;div class="math"&gt;\begin{equation}
\min\limits_{x} \sum\limits_{k = 1}^n {{e_k}{{\left( {{x_k},{z_k}} \right)}^T}{\Omega _k}{e_k}\left( {{x_k},{z_k}} \right)}
\end{equation}&lt;/div&gt;
&lt;h3&gt;核函数 robust kernel function&lt;/h3&gt;
&lt;p&gt;在图中，可能会存在错误的边，对应最小二成中某一误差项过于的大，或者根本不合理。类似于观测中的outlier。因为算法目标是整体误差结果最小化，这会导致整体的结果出现偏移。如何有效的剔除outlier，或者最小化它的影响，是算法稳定的一大目标。
核函数的存在就是限制误差的增长。把传统的误差二范数度量，替换成一个在误差大的情况下，增长没有那么快的函数，同时，还必须保证自身的光滑可导行。&lt;/p&gt;
&lt;h2&gt;误差信息矩阵，系统信息矩阵&lt;/h2&gt;
&lt;p&gt;边信息矩阵&lt;span class="math"&gt;\(\Omega\)&lt;/span&gt;，协方差矩阵的逆，最小二乘的权重，相关性越高，协方差越大，该误差权重越小。如果协方差越小，表示这次测量(边，constraint)越准，越值得相信。&lt;/p&gt;
&lt;p&gt;信息矩阵有如下性质：&lt;/p&gt;
&lt;p&gt;1, 对称矩阵 symmetric matrix
2, 对角线上元素为方差，如果各个误差间独立，那么为对角阵。对角阵元素大小表示误差的权重。&lt;/p&gt;
&lt;p&gt;举例：&lt;span class="math"&gt;\(\Omega_{ij}代表i顶点与j顶点之间误差变量的协方差矩阵。如果一个边的对应的误差参数是\)&lt;/span&gt;[\Delta x,\Delta y,\Delta \theta]^T&lt;span class="math"&gt;\(，
那么对应的协方差矩阵\)&lt;/span&gt;\Omega_{ij} \in
\mathbbR^{3x3}&lt;span class="math"&gt;\(，因为是对称矩阵的缘故，只需要6个变量来存储:
$(inf_{xx}, inf_{xy}, inf_{x\theta}, inf_{yy}, inf_{y\theta}, inf_{\theta\theta})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(e_{ij}(X_i, X_j) \in \mathbb R^{3x1}\)&lt;/span&gt;, &lt;/p&gt;
&lt;p&gt;系统信息矩阵H&lt;/p&gt;
&lt;h3&gt;full SLAM H的求解&lt;/h3&gt;
&lt;h3&gt;online SLAM H的维护更新&lt;/h3&gt;
&lt;h2&gt;矩阵形式的理解&lt;/h2&gt;
&lt;p&gt;最后落实到代码中，需要切实的理解数学中矩阵运算的具体分解步骤&lt;/p&gt;
&lt;h2&gt;相关博文&lt;/h2&gt;
&lt;p&gt;非常感谢相关博主无私的分享他们的理解！&lt;/p&gt;
&lt;h2&gt;从信息矩阵的方式去理解&lt;/h2&gt;
&lt;p&gt;在概率机器人一书中，推导方式是从信息滤波器角度推导的information filter,
而不是从最小二乘。&lt;/p&gt;
&lt;p&gt;在信息矩阵的概念下，GraphSLAM只需要维护information matrix
&lt;span class="math"&gt;\(\Omega\)&lt;/span&gt;与信息向量&lt;span class="math"&gt;\(\xi\)&lt;/span&gt;，状态结果，也就是期望值，可以通过&lt;span class="math"&gt;\(\mu = {\Omega}^{-1} \xi\)&lt;/span&gt;
计算得到。同时，可以对信息矩阵，信息向量尽心消元操作，使的其只包含pose信息。
然后先求得所有位姿信息，然后根据路标与相应的观测到次路标的位姿节点，求解路标信息，
得到地图信息。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="SLAM"></category></entry><entry><title>Apollo代码结构</title><link href="/apollodai-ma-jie-gou.html" rel="alternate"></link><updated>2019-02-07T20:14:27+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-07:apollodai-ma-jie-gou.html</id><summary type="html">&lt;p&gt;https://blog.csdn.net/tianzy16/article/details/83988402&lt;/p&gt;</summary><category term="SLAM"></category></entry><entry><title>Cartographer源码</title><link href="/cartographeryuan-ma.html" rel="alternate"></link><updated>2019-02-07T20:13:11+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-07:cartographeryuan-ma.html</id><summary type="html">&lt;p&gt;https://zhuanlan.zhihu.com/p/48010119&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/MyArrow/article/details/80605118
https://blog.csdn.net/u012209790/article/details/82629422&lt;/p&gt;</summary><category term="SLAM"></category></entry><entry><title>机器人局部蔽障</title><link href="/ji-qi-ren-ju-bu-bi-zhang.html" rel="alternate"></link><updated>2019-02-07T18:48:59+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-02-07:ji-qi-ren-ju-bu-bi-zhang.html</id><summary type="html">&lt;h2&gt;动态窗口法(Dynamic window approach)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据运动模型，机器人参数，生成一个合理的搜索空间(search space）&lt;/li&gt;
&lt;li&gt;根据评价函数，选取最后方案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态窗口法主要是在速度(v,w)空间(线速度，角速度)中，采样多种速度可能性，并模拟
在一个固定时间sim_period内，机器人的轨迹，得到多组轨迹以后，对轨迹进行评价，
选取最优轨迹对应的速度来驱动机器人。
如何选取可行的二维速度空间，并且使之尽可能小，这样需要模拟的可能路径就少。
在DWA中，这个窗口的确定是根据机器人的加减速性能(kinematic constraint)&lt;/p&gt;
&lt;p&gt;(程序每隔0.25秒运行一次，sim_period = 0.25s, 计算出在此时刻，根据不同的速度采样，sim_period以后各自不同的轨迹，选取其中最符合最优标准的速度，转换成机器人控制，完成一次的控制。然后等待下一个sim_period再进行同样的循环操作)&lt;/p&gt;
&lt;p&gt;具体解释，可参考：机器人局部避障的动态窗口法(dynamic window approach)&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2&gt;动态窗口法缺点&lt;/h2&gt;
&lt;p&gt;http://ais.informatik.uni-freiburg.de/teaching/ss10/robotics/slides/16-pathplanning.pdf&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;https://blog.csdn.net/heyijia0327/article/details/44983551&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="SLAM"></category></entry><entry><title>SLAM</title><link href="/slam.html" rel="alternate"></link><updated>2019-01-29T16:27:32+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-01-29:slam.html</id><summary type="html">&lt;h2&gt;纯激光SLAM地图构建&lt;/h2&gt;
&lt;p&gt;如果平台只有激光测距的传感器，那个这个系统只有观测方程，没有运动方程。&lt;/p&gt;
&lt;p&gt;在卡尔曼滤波中，步骤分为预测与更新，没有了运动方程，这里只能有一步。由于没有额外
的信息来消除误差，在运动/观测过程中的误差不会被消除，只会一直积累。&lt;/p&gt;
&lt;p&gt;这需要依赖后端的图优化来一次性优化所有地图的信息，这里回环检测就非常重要，它添加额外的非常
重要的信息。也就是在图优化的术语中，添加了一个非常强的约束。&lt;/p&gt;
&lt;p&gt;对于运动的估计，利用点云匹配的方法求出，也就是位移与旋转。常用的方法有ICP。在这里，
算法的稳定性尤为重要，因为这是唯一的估计运动的来源。由于，相邻的测量数据里只有部
分信息重合，需要避免误匹配。同时，计算量会很大，效率很重要。&lt;/p&gt;
&lt;p&gt;scan to scan
scan to map
map to map&lt;/p&gt;
&lt;h2&gt;landmark extraction from laser scan&lt;/h2&gt;
&lt;p&gt;也称作环境feature extraction?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spike landmarks, 对于环境中类似于脱离背景的人，因为其筛选标准，会错误判断为路标&lt;/li&gt;
&lt;li&gt;RANSAC, use line extraction, 对于环境中移动的人，有一定的稳定特性。但是对于块状移动物体，例如汽车，肯能也会错误的识别为路标&lt;/li&gt;
&lt;li&gt;scan mathing, 不提取特征，直接比较相邻时刻的laser scans, 计算量问题，稳定性问题，data point reduce, data align问题。后续有看到feature-based laser scan mathing 文章。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;KF-SLAM, online SLAM&lt;/h2&gt;
&lt;p&gt;&lt;figure&gt;
&lt;img src="images/slam04_ekf_state.png" alt="EKF state" title="EKF state" style="max-width:80%;max-height:80%"/&gt;
&lt;figcaption&gt; Figure. EKF state representation&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src="images/slam08_kf_complexity.png" alt="EKF complexity" title="EKF complexity" style="max-width:80%;max-height:80%"/&gt;
&lt;figcaption&gt; Figure. EKF complexity&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;/figcaption&gt;
&lt;/figure&gt;
因为图1中状态的表示与路标数成比例，协方差矩阵(信息矩阵)的大小是路标数量的二阶形式。在卡尔曼滤波过程中，一直需要维护更新这个矩阵。&lt;/p&gt;
&lt;h3&gt;EKF&lt;/h3&gt;
&lt;h3&gt;UKF&lt;/h3&gt;
&lt;h3&gt;SEIF&lt;/h3&gt;
&lt;h2&gt;拥有反馈的SLAM系统&lt;/h2&gt;
&lt;p&gt;在这个系统中，有多种传感器，融合所有传感器的信(sensor fusion)，可以修正一定的误差&lt;/p&gt;
&lt;h2&gt;Online SLAM vs Full SLAM&lt;/h2&gt;
&lt;p&gt;在没有回环检测的时候，卡尔曼滤波与图优化的优劣，strip状的路径
卡尔曼滤波计算更小，数据存储越小？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端&lt;ol&gt;
&lt;li&gt;特征点提取&lt;/li&gt;
&lt;li&gt;特征匹配，计算相对运动矩阵，估计位姿，估计路标坐标&lt;/li&gt;
&lt;li&gt;回环检测&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;后端&lt;ol&gt;
&lt;li&gt;优化，更新位姿，路标&lt;/li&gt;
&lt;li&gt;parameterization: 优化方法求导，四元数
iterative non-linear optimization: LM, Gauss-Newton etc.
solve symstem of linear euqation: 计算
matrix decomposition: 计算
matrix sparseness: 问题的结构，优化计算
numeric stability(condition number):
Marginalization: 消原，或者局部更新，window
outlier: &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Data association&lt;/h2&gt;
&lt;p&gt;无论是在滤波方法，还是图优化方法中，都有一个假设，我们知道在一个位姿下，观测到的环境特征与之前特征的匹配。
这是一个需要单独解决的问题，称作Data association。在图优化框架中，这部分属于前端工作。&lt;/p&gt;
&lt;p&gt;滤波模型，利用观测，对预测进行更新修正。图优化模型，利用观测，来建立顶点间的边，也就是约束。
所以，这两种算法正确的前提是，对于观测误差计算中，用到的data association的正确性。&lt;/p&gt;
&lt;p&gt;Data association也就是解决这样一个问题：在某个位姿下，每一个观测到的数据，与之前的观测，或者与地图的对应关系。
例如提供这样的一个信息： &lt;span class="math"&gt;\(c_{t}^{i} = j\)&lt;/span&gt;， &lt;span class="math"&gt;\(i\)&lt;/span&gt;-th 测量值观测到的是环境(map)中&lt;span class="math"&gt;\(j\)&lt;/span&gt;个特征(landmark)&lt;/p&gt;
&lt;p&gt;这与位姿优化估计，地图建立是完全不同领域的问题，但是是一个SLAM系统稳定正确工作的重要前提。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;raw data&lt;/li&gt;
&lt;li&gt;feature based&lt;ul&gt;
&lt;li&gt;feature correspondences&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;http://ais.informatik.uni-freiburg.de/teaching/ws12/mapping/pdf/slam04-ekf-slam.pdf&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;http://ais.informatik.uni-freiburg.de/teaching/ws12/mapping/pdf/slam08-kf-wrapup.pdf&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="SLAM"></category></entry><entry><title>简单BA代码分析</title><link href="/jian-dan-badai-ma-fen-xi.html" rel="alternate"></link><updated>2019-01-15T08:36:12+01:00</updated><author><name>Nekoo</name></author><id>tag:,2019-01-15:jian-dan-badai-ma-fen-xi.html</id><summary type="html">&lt;p&gt;简单代码分析，帮助自己从概念到代码的理解。代码使用Eigen, ceres solver第三方软件库。&lt;/p&gt;
&lt;h1&gt;问题假设&lt;/h1&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P^{c}_{ij}\)&lt;/span&gt;: 路标(point)j在i相机位姿下，在相机坐标下的观测坐标&lt;span class="math"&gt;\([Px^{c} Py^{c}]^T\)&lt;/span&gt;(观测数据)&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(T_{i} = [rotation matrix, translation]\in \mathbb {R}^{6}\)&lt;/span&gt; 或者&lt;span class="math"&gt;\(T = [Quaternion, translation] \in \mathbb {R}^{7}\)&lt;/span&gt; 相机位姿(pose)初始估计 (前端计算数据)&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P^{w}_{j} = [Px^{w} Py^{w} Pz^{w}]\)&lt;/span&gt;路标(point)在世界坐标系下的初始估计值(前端计算数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经过调整后相机的位姿(pose)&lt;/li&gt;
&lt;li&gt;与调整后的路标在世界坐标系下的坐标。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$ \overline {P^{c}_{ij}} = h(T_{i}, P^{w}_{ij})$$&lt;/div&gt;
&lt;p&gt;
给定相机位姿，路标世界坐标，计算投影坐标&lt;span class="math"&gt;\(h : SE(3) × \mathbb {R}^{3} \to \mathbb {R}^{2}\)&lt;/span&gt;
因为投影为平面，所以只有二维，世界坐标维三维。&lt;/p&gt;
&lt;p&gt;cost function, reprojection error:
&lt;/p&gt;
&lt;div class="math"&gt;$$ e = \sum_{i} {\sum_{j} {\Vert(h(T_{i}, P^{w}_{ij}) - P^{c}_{ij})\Vert^2}}$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(h\)&lt;/span&gt;这里可以分为两步
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
P^{w'} &amp;amp;= f(T, P^{w}) = TP^{w} = RP^{w} + t: \mathbb {R}^3 \to \mathbb {R}^3 \\
\overline {P^{c}} &amp;amp;= g(P^{w'}) = [\frac {Px^{w'}}{Pz^{w'}} \frac{Py^{w'}}{Pz^{w'}}]^T: \mathbb {R}^3 \to \mathbb {R}^2 \\
\overline {P^{c}} &amp;amp;= g(f(T, P^{w}))
\end{align*}&lt;/div&gt;
&lt;p&gt;非线性最小二乘优化，迭代方法，需要求得对于优化标量偏导Jacobian矩阵,
  以及迭代更新计算。这里，优化的变量为位姿&lt;span class="math"&gt;\(T \in \mathbb {R}^6\)&lt;/span&gt;与&lt;span class="math"&gt;\(P^{w} \in
  \mathbb {R}^3\)&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;cost function Jabian矩阵推导&lt;/h1&gt;
&lt;p&gt;根据求导chain rule:
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
1)\; \pdiff{h}{P^{w}} &amp;amp;= \pdiff{g(P^{w'})}{f}\pdiff{f}{P^{w}}\\
2)\; \pdiff{h}{T} &amp;amp;= \pdiff{g(P^{w'})}{f}\pdiff{f}{T}\\
\end{align*}&lt;/div&gt;
&lt;div class="math"&gt;\begin{gather*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
\pdiff{g(P^{w'})}{f} &amp;amp;= 
\left[
  \begin{array}{ccc}
  \frac {1}{Pz^{w'}} &amp;amp; 0 &amp;amp; \frac {Px^{w'}}{(Pz^{w'})^2} \\
  0 &amp;amp; \frac {1}{Pz^{w'}} &amp;amp; \frac {Py^{w'}}{(Pz^{w'})^2} \\
  \end{array}
\right] = \frac {1}{Pz^{w'}}
\left[
  \begin{array}{ccc}
  1 &amp;amp; 0 &amp;amp; \frac {Px^{w'}}{Pz^{w'}} \\
  0 &amp;amp; 1 &amp;amp; \frac {Py^{w'}}{Pz^{w'}} \\
  \end{array}
\right]
\end{gather*}&lt;/div&gt;
&lt;p&gt;这里2)的导数在SE(3)空间无法计算，因为没有定义的加法，因此使用lie group与lie
algebra计算。
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
\pdiff{f}{T} \to \pdiff{TP}{\delta\xi}
&amp;amp;= \lim_{\delta\xi \to 0}{\frac {exp(\delta\xi^{\wedge})exp(\xi^{\wedge})P -exp(\xi^{\wedge})P}{\delta\xi}} \\
&amp;amp;\approx \lim_{\delta\xi \to 0}{\frac {(I + \delta\xi^{\wedge})exp(\xi^{\wedge})P -exp(\xi^{\wedge})P}{\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac {\delta\xi^{\wedge}exp(\xi^{\wedge})P}{\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left [\begin{array}{cc} \delta\varphi^{\wedge} &amp;amp; \delta\rho \\ 0^T &amp;amp; 0 \\ \end{array} \right] \left[ \begin{array}{c} RP + t \\ 1 \end{array} \right]}
      {\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left[ \begin{array}{c} \delta\varphi^{\wedge}(RP + t) + \delta\rho \\ 0 \end{array} \right]}
      {\delta\xi}}
\end{align*}&lt;/div&gt;
&lt;p&gt;T对应的李代数为&lt;span class="math"&gt;\(\delta\xi = [\delta\varphi \; \delta\rho]^T\)&lt;/span&gt;, 对他们按顺序求导得到
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\def\pdiff#1#2{\frac{\partial #1}{\partial #2}}
\pdiff{f}{T} \to \pdiff{TP}{\delta\xi}
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left[ \begin{array}{c} \delta\varphi^{\wedge}P^{w'} + \delta\rho \\ 0 \end{array} \right]}
      {\delta\xi}} \\
&amp;amp;= \lim_{\delta\xi \to 0}{\frac
      {\left[ \begin{array}{c} -{P^{w'}}^{\wedge}\delta\varphi + \delta\rho \\ 0 \end{array} \right]}
      {\delta\xi}} \\
&amp;amp;= \left[ \begin{array}{cc} -{P^{w'}}^{\wedge} &amp;amp; I \\ 0^T &amp;amp; 0^T \end{array} \right]
\end{align*}&lt;/div&gt;
&lt;p&gt;推导过程与这里想吻合，具体计算可以参考这里代码.&lt;/p&gt;
&lt;p&gt;&lt;a href="/pdfs/Visual_SLAM_Tutorial_Bundle_Adjustment.pdf"&gt;Visual SLAM Tutorial: Bundle Adjustment&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://github.com/lirenlin/ba_demo_ceres"&gt;github source code fork&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;优化参量更新&lt;/h1&gt;
&lt;p&gt;注意这里对李代数求导，对于原参数的更新，必须返回到SE(3)。
&lt;/p&gt;
&lt;div class="math"&gt;$$X = X + \Delta X$$&lt;/div&gt;
&lt;p&gt;
这里&lt;span class="math"&gt;\(\Delta X\)&lt;/span&gt;是用Jacobian矩阵求得。因为位姿相关部分是用李代数求得，所以&lt;span class="math"&gt;\(\Delta X\)&lt;/span&gt;位姿更新部分也是李代数，
在更新T参数时，需要变换到SE(3)下。对于路标位置，可以直接更新。
这个使用ceres solver里面的LocalParameterization实现，重载plus成员函数。&lt;/p&gt;
&lt;p&gt;从李代数到Transform matrix的转换在《视觉slam十四讲》李代数章节讲的很清楚。&lt;/p&gt;
&lt;p&gt;so(3)李代数实际上由旋转向量组成，所以转换遵循Angle-Aix, Rotation matrix, Quaternion变换关系。&lt;/p&gt;
&lt;h1&gt;代码备注&lt;/h1&gt;
&lt;p&gt;Eigen库里面有大量的运算符重载，例如四元数表示的旋转可以直接与三维坐标想成得到旋转后的向量。
在数学上是不行的。&lt;/p&gt;
&lt;h1&gt;继续学习&lt;/h1&gt;
&lt;p&gt;李群，李代数的数学意义，manifold tangent space目前还是不清楚。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《视觉slam十四讲》  &lt;/li&gt;
&lt;li&gt;&lt;a href="/pdfs/Visual_SLAM_Tutorial_Bundle_Adjustment.pdf"&gt;Visual SLAM Tutorial: Bundle Adjustment&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/lirenlin/ba_demo_ceres"&gt;github source code fork&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/sVjy9kr-8qc9W9VN78JoDQ"&gt;李代数讲解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="BundleAdjustment"></category></entry></feed>